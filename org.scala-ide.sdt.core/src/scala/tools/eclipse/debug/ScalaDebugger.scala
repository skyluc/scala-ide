package scala.tools.eclipse.debug

import org.eclipse.jdt.debug.core.IJavaBreakpointListener
import org.eclipse.jdt.debug.core.IJavaDebugTarget
import org.eclipse.jdt.debug.core.IJavaBreakpoint
import org.eclipse.jdt.debug.core.IJavaLineBreakpoint
import org.eclipse.jdt.debug.core.IJavaThread
import org.eclipse.jdt.debug.core.IJavaType
import org.eclipse.jdt.debug.core.JDIDebugModel
import org.eclipse.jdt.internal.debug.core.model.JDIStackFrame
import com.sun.jdi.AbsentInformationException
import com.sun.jdi.Method
import org.eclipse.debug.core.model.IBreakpoint
import org.eclipse.core.resources.ResourcesPlugin

object ScalaDebugger extends IJavaBreakpointListener {

  /* from IJavaBreakpointListener */
  
  JDIDebugModel.addJavaBreakpointListener(this)

  /**
   * Listen to the events generated by the class prepare breakpoint we created
   */
  def breakpointHit(thread: IJavaThread, breakpoint: IJavaBreakpoint): Int = {
    IJavaBreakpointListener.DONT_CARE
  }

  def addingBreakpoint(target: IJavaDebugTarget, breakpoint: IJavaBreakpoint): Unit = {
    // not interested in this event
  }

  def breakpointHasCompilationErrors(breakpoint: IJavaLineBreakpoint, errors: Array[org.eclipse.jdt.core.dom.Message]): Unit = {
    // not interested in this event
  }

  def breakpointHasRuntimeException(breakpoint: IJavaLineBreakpoint, exception: org.eclipse.debug.core.DebugException): Unit = {
    // not interested in this event
  }

  def breakpointInstalled(target: IJavaDebugTarget, breakpoint: IJavaBreakpoint): Unit = {
    // not interested in this event
  }

  def breakpointRemoved(target: IJavaDebugTarget, breakpoint: IJavaBreakpoint): Unit = {
    // not interested in this event
  }

  def installingBreakpoint(target: IJavaDebugTarget, breakpoint: IJavaBreakpoint, javaType: IJavaType): Int = {
    // not interested in this event
    IJavaBreakpointListener.DONT_CARE
  }
  
  /**
   * Seamless stepover
   * TODO: move to a Scala stack frame class
   */
  def stepOver(stackFrame: JDIStackFrame) {
        
    import scala.collection.JavaConverters._
    
    val method= stackFrame.getUnderlyingMethod
    val nestedTypes= method.declaringType.nestedTypes
    val currentLine= stackFrame.getLineNumber
    val methodLastLine= method.allLineLocations.asScala.map(_.lineNumber).max
    val methods= method.declaringType.methods
    
    def methodToLines(m: Method) =
      try {
        m.allLineLocations.asScala.map(_.lineNumber)
      } catch {
        case e: AbsentInformationException =>
          Nil
        case e =>
          throw e
      }
    
    val nextMethodFirstLine= (methods.asScala.flatten(methodToLines(_)).filter(_ > methodLastLine) :+ Int.MaxValue).min
    
    val closuresInRange= nestedTypes.asScala.flatten(_.methods.asScala).filter(m => {
      val minLine= (methodToLines(m) :+ Int.MaxValue).min
      minLine >= currentLine && minLine < nextMethodFirstLine && m.name.startsWith("apply$")
    })
    
    import scala.collection.mutable.Map
    
    val attributes= Map(IBreakpoint.PERSISTED -> true)
    
    for (m <- closuresInRange) {
      JDIDebugModel.createMethodEntryBreakpoint(ResourcesPlugin.getWorkspace().getRoot(), m.declaringType.name, m.name, m.signature, methodToLines(m).min, -1, -1, -1, true, attributes.asJava)
    }
  
    stackFrame.stepOver
  }
}